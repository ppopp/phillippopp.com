<!DOCTYPE html>
<html>
	<meta charset="utf-8">
	<head>
		<title>Zoomable Treemap</title>
		<style>
		
		#chart {
			/*
			width: 800px;
			height: 500px;
			background: #bbb;
			*/
		}

		#budget_map {
			display: block;
			margin: auto;
		}

		#table {
			display: block;
			width: 800px;
			margin: auto;
		}


		table,tbody {
			border-collapse:collapse;
			border: 0px;
		}

		th {
			text-align: left;
		}

		th,td
		{
			border-top: 1px solid black;
			border-left: 0px;
			border-right: 0px;
			border-collapse:collapse;
			padding: 5px;
		}

		.table_money {
			text-align: right;
		}
		.table_item {
			width: 100%;
		}

		text {
			pointer-events: none;
		}

		#spacer {
			height: 30px;
		}

		.grandparent text { /* header text */
			font-weight: bold;
			font-size: medium;
			font-family: "Open Sans", Helvetica, Arial, sans-serif; 
		}

		#tooltip {
			background: #333;
			color: #FFF;
			padding: 5px;
		}

		.tooltip {
			padding: 0px;
			margin: 0px;
		}

		rect {
			fill: none;
			stroke: #fff;
		}

		rect.parent, .grandparent rect {
			stroke-width: 1px;
		}

		.grandparent rect {
			fill: #fff;
		}

		.children rect.parent, .grandparent rect {
			cursor: pointer;
		}

		rect.parent {
			pointer-events: all; 
		}

		.square {
			width: 10px;
			height: 10px;
		}

		.textdiv { /* text in the boxes */
			font-size: small;
			padding: 5px;
			/*font-family: "Open Sans", Helvetica, Arial, sans-serif; */
			color: white;
		}

		.amount {
			padding: 0px;
			margin: 0px;
			font-size: medium
		}

		.name {
			padding: 0px;
			margin: 0px;
			font-size: small 
		}
			

		</style>
	</head>
	<body>
		<div id="chart">
		</div>
		<div id="spacer">
		</div>
		<table id="table">
			<tbody>
			</tbody>
		</table>

		<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
		<script src="../js/source.js" charset="utf-8"></script>
		<script src="../js/data.js" charset="utf-8"></script>
		<script>

			function tooltip_text(node) {
				node.display = '<p class="tooltip title">' + node.key + '</p>';
				node.display += '<p class="tooltip amount">' + format_number(node.value) + '</p>';
				var percent = 1.0;
				if (node.parent) {
					percent = node.value / node.parent.value;
				}
				node.display += '<p class="tooltip percentage">' + format_percentage(percent) + '</p>';
			}

			/* determine current view in hierarchy based on url hash */
			function get_hash_location(root) {
				if (window.location.hash.length < 2) {
					return root;
				}
				return cruncher.spelunk(
					root, 
					window.location.hash.replace("#", "").split(".")
				);
			}

			function set_hash_location(node) {
				var keys = cruncher.path(node);
				window.location.hash = keys.join('.');
			}


			/* fusion table info */
			var fusion_api_key = 'AIzaSyCnWo1USrkSKnN6oy02tNeWfg6aFSg0OI8';
			var fusion_table_id = '1V2R7lsdg-GTbGOZ_h_DrGOa-Gfqk1PGA9h_n5zwU';
			//var hierarchy = ['Fund Description', 'Department', 'Division'];
			var hierarchy = ['Fund Description', 'Department', 'Division', 'Account Category'];
			//var hierarchy = ['Department', 'Division', 'Account Category'];
			var value_selector = 'balance';
			/*var value_selector = 'income';*/
			/* visualization parameters */
			var max_funds = 40;


			/* layout settings */
			var margin = {top: 25, right: 0, bottom: 0, left: 0};
			var width = 800;
			var height = 500 - margin.top - margin.bottom;
			var min_area_for_text = 0.0125;

			var format_number = d3.format("$,d");
			var format_percentage = d3.format('.2%');
			var transitioning;
			var colors = d3.scale.category10().domain([0, max_funds]);
			var tooltip = d3.select("body")
				.append("div")
				.style("position", "absolute")
				.style("z-index", "10")
				.style("visibility", "hidden")
				.attr("id", "tooltip")
				.text("a simple tooltip");

			var treemap = d3.layout.treemap()
				.sort(function(a, b) { return a.value - b.value; })
				.round(false)
				.ratio(height / width)
				.value(function(d) { 
					/* some values are zero or negative which really screw up the 
					 * layout calculations */
					if (d[value_selector] < 0) {
						return Math.abs(d[value_selector]);
					}
					if (d[value_selector] <= 0) {
						return 1;
					}
					return d[value_selector];
				});

			var cruncher = ob.data.hierarchy();
			url = ob.fusion(fusion_api_key, fusion_table_id).url(hierarchy, 'Amount');
			d3.json(url, function(data) {
				var root = cruncher.crunch(data.rows, hierarchy);
				/* caculate data percentages */
				cruncher.apply(root, function(node) {
					if (node.parent) {
						node.precentage = node.value / node.parent.value;
					}
					else {
						node.percentage = 1.0;
					}
				});

				/* create svg */
				var svg = d3.select("#chart").append("svg")
					.attr("id", "budget_map")
					.attr("width", width + margin.left + margin.right)
					.attr("height", height + margin.bottom + margin.top)
					.append("g")
					.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
					.style("shape-rendering", "crispEdges");

				var grandparent = svg.append("g")
					.attr("class", "grandparent");

				grandparent.append("rect")
					.attr("y", -margin.top)
					.attr("width", width)
					.attr("height", margin.top);

				grandparent.append("text")
					.attr("x", 6)
					.attr("y", 6 - margin.top)
					.attr("dy", ".75em");

				var node = get_hash_location(root);
				
				initialize(root);
				layout(root);
				cruncher.apply(root, tooltip_text);
				display(node);

				function initialize(root) {
					root.x = root.y = 0;
					root.dx = 1.0;
					root.dy = 1.0;
					root.depth = 0;
				}

				function layout(d) {
					if (d.values) {
						/* only layout up to a maximum number of children */
						d.values.sort(function(a, b) {
							return b[value_selector] - a[value_selector];
						});
						d.children = d.values.slice(0, max_funds);
						treemap.nodes({children: d.children});
						d.children.forEach(function(c) {
							c.visible = true;
						});
						d.values.slice(max_funds).forEach(function (c) {
							c.x = 0.0;
							c.y = 0.0;
							c.dx = 1.0;
							c.dy = 1.0;
							c.visible = false;
						});
						d.values.forEach(function(c) {
							/* need to correct parent assigned during treemap */
							c.parent = d;
							layout(c);
						});
					}
					if (d.parent) {
						d.area = d.dx * d.dy;
					}
				}

				/* display show the treemap and writes the embedded transition function */
				function display(d) {
					console.log(d.children);
					var disp = {};
					set_hash_location(d);
					disp.d = d;

					disp.x = d3.scale.linear()
						.domain([0, 1.0])
						.range([0, width]);

					disp.y = d3.scale.linear()
						.domain([0, 1.0])
						.range([0, height]);

					disp.text = function(text) {
						text.attr("x", function(d) { return disp.x(d.x) + 6; })
							.attr("y", function(d) { return disp.y(d.y) + 6; });
					}

					disp.rect = function(rect) {
						rect.attr("x", function(d) { return disp.x(d.x); })
							.attr("y", function(d) { return disp.y(d.y); })
							.attr("width", function(d) { return disp.x(d.x + d.dx) - disp.x(d.x); })
							.attr("height", function(d) { return disp.y(d.y + d.dy) - disp.y(d.y); });
					}

					disp.foreign = function(foreign) { 
						foreign.attr("x", function(d) { return disp.x(d.x); })
							.attr("y", function(d) { return disp.y(d.y); })
							.attr("width", function(d) { return disp.x(d.x + d.dx) - disp.x(d.x); })
							.attr("height", function(d) { return disp.y(d.y + d.dy) - disp.y(d.y); });
					}


					/* create grandparent bar at top */
					grandparent.datum(d)
						.on("click", function(d) {
							disp.transition(d.parent, -1, false);
						})
						.select("text")
						.text(function(d) { 
							var crumbs = [root.key];
							crumbs = crumbs.concat(cruncher.path(d));
							return crumbs.join(' > ');
						});

					disp.g = svg.insert("g", ".grandparent")
						.datum(d)
						.attr("class", "depth");

					/* add in data */
					var g = disp.g.selectAll("g")
						.data(d.children)
						.enter().append("g")
						.on("click", function (d, i) { disp.transition(d, i, true);} )
						.attr("class", "groups");

					/* transition on child click */
					g.filter(function(d) { return d.children; })
						.classed("children", true)
						.on("click", function (d, i) { disp.transition(d, i, true); });

					/* write parent rectangle */
					g.append("rect")
						.attr("class", "parent")
						.style("fill", function(d, i) { return colors(i);})
						.call(disp.rect)
						.on("mouseover", function(d, i) { 
							d3.select(this).style("fill", d3.rgb(colors(i)).darker());
							tooltip.style("visibility", "visible");
							tooltip.html(d.display);
						})
						.on("mousemove", function(){
							tooltip.style("top", (event.pageY-10)+"px")
								.style("left",(event.pageX+10)+"px");
						})
						.on("mouseout", function(d, i) {
							d3.select(this).style("fill", colors(i));
							tooltip.style("visibility", "hidden");
						})
						.append("title")
						.attr("class", "text")
						.text(function(d) { return format_number(d[value_selector]); });

					/* Adding a foreign object instead of a text object, allows for text wrapping */
					var fo = g.append("foreignObject")
						.call(disp.rect)
						.attr("class","foreignobj")
						.append("xhtml:div")
						.attr("class", "textdiv")
						.on("mouseover", function(d, i) { 
							d3.select(this.parentNode.parentNode)
								.select("rect")
								.style("fill", d3.rgb(colors(i))
								.darker());
							tooltip.style("visibility", "visible");
							tooltip.html(d.display);
						})
						.on("mousemove", function(){return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");})
						.on("mouseout", function(d, i) { 
							d3.select(this.parentNode.parentNode).select("rect").style("fill", colors(i));
							tooltip.style("visibility", "hidden");
						});
					fo.append("xhtml:div") 
						.attr("dy", ".75em")
						.html(function(d) { 
							return d.area >= min_area_for_text ? format_number(d[value_selector]) : "";
						})
						.attr("class","amount");
					fo.append("xhtml:div") 
						.attr("dy", ".75em")
						.html(function(d) { 
							return d.area >= min_area_for_text ? d.key : "";
						})
						.attr("class","name"); //textdiv class allows us to style the text easily with CSS
					/* draw table */
					display_table(d);

					/* create transition function for transitions */
					disp.transition = function(d, i, direction) {
						if (transitioning || !d) return;
						if (!d.children) return;
						transitioning = true;
						/* these are default layout values for items that had
						 * too small of values to be laid out by d3's treemap
						 */
						var small_span = {x: 0.99, dx: 0.01, y: 0.99, dy: 0.01};
						var span1 = d.visible ? d : small_span;
						var span2 = disp.d.visible ? disp.d : small_span;

						/* create new display and update it's coordanates */
						var disp2 = display(d);
						if (direction) {
							disp2.x.domain([
								-1.0 * span1.x / span1.dx,
								(1.0 - span1.x) / span1.dx
							]);
							disp2.y.domain([
								-1.0 * span1.y / span1.dy,
								(1.0 - span1.y) / span1.dy
							]);
						}
						else {
							/* map the new display ata to exist around the
							 * currently displayed data */
							disp2.x.domain([span2.x, span2.x + span2.dx]);
							disp2.y.domain([span2.y, span2.y + span2.dy]);

						}
						/* Fade-in entering text. */
						disp2.g.selectAll("text").style("fill-opacity", 0);
						disp2.g.selectAll("foreignObject div").style("display", "none"); 

						/* Transition to the new view. */
						disp2.g.selectAll("text")
							.call(disp2.text)
							.style("fill-opacity", 0);
						disp2.g.selectAll("rect")
							.call(disp2.rect)
							.style("fill-opacity", 0);

						disp2.g.selectAll(".textdiv").style("display", "block"); 
						disp2.g.selectAll(".foreignobj").call(disp2.foreign); 

						var t1 = disp.g.transition().duration(750)
						var t2 = disp2.g.transition().duration(750);

						/* update domain mappings for the state at the end of
						 * the transition */
						if (direction) {
							/* map current display to extend beyond bounds */
							disp.x.domain([span1.x, span1.x + span1.dx]);
							disp.y.domain([span1.y, span1.y + span1.dy]);
						}
						else {
							/* map current display to shrink within bounds */
							
							disp.x.domain([
								-1.0 * span2.x / span2.dx,
								(1.0 - span2.x) / span2.dx
							]);
							disp.y.domain([
								-1.0 * span2.y / span2.dy,
								(1.0 - span2.y) / span2.dy
							]);
						}
						/* set new display to take up entire square */
						disp2.x.domain([0, 1.0]);
						disp2.y.domain([0, 1.0]);

						/* Enable anti-aliasing during the transition. */
						svg.style("shape-rendering", null);

						/* Draw child nodes on top of parent nodes. */
						if (direction) {
							svg.selectAll(".depth")
								.sort(function(a, b) { return b.depth - a.depth; });
						}
						else {
							svg.selectAll(".depth")
								.sort(function(a, b) { return a.depth - b.depth; });
						}

						// Transition to the new view.
						t1.selectAll("text").call(disp.text).style("fill-opacity", 0);
						t2.selectAll("text").call(disp2.text).style("fill-opacity", 1);
						t1.selectAll("rect")
							.call(disp.rect)
							.style("fill-opacity", 0)
							.style("stroke-opacity", 0);
						t2.selectAll("rect")
							.call(disp2.rect)
							.style("fill-opacity", 1)
							.style("stroke-opacity", 1);

						t1.selectAll(".textdiv").style("display", "none"); 
						t1.selectAll(".foreignobj").call(disp.foreign); 
						t2.selectAll(".textdiv").style("display", "block"); 
						t2.selectAll(".foreignobj").call(disp2.foreign); 

						/* Remove the old node when the transition is finished. */
						t1.remove().each("end", function() {
							svg.style("shape-rendering", "crispEdges");
							transitioning = false;
						});
						t1.select(".depth").remove();

						transitioning = false;
					}

					function display_table(node) {
						var display_count = 10;
						var t = d3.select("#table").select("tbody");
						t.selectAll("th").remove();
						d3.select("#more_button").remove();
						t.append("th");
						t.append("th").attr("class", "table_item").html("Item");
						t.append("th").attr("class", "table_money").html("Income");
						t.append("th").attr("class", "table_money").html("Expense");
						t.append("th").attr("class", "table_money").html("Balance");

						t.selectAll(".row").remove();
						var rows = t.selectAll(".row").data(node.values);
						var row = rows.enter().append("tr").attr("class", "row")
						row.style("visibility", function(d, i) { 
								return i > display_count ? "hidden" : "visible";
							})
							.style("display", function(d, i) { 
									return i > display_count ? "none" : "table-row";
							});
						row.append("td")
							.append("div")
							.attr("class", "square")
							.style("background-color", function(d, i) { 
								return colors(i); 
							})
						row.append("td")
							.attr("class", "table_item")
							.html(function(d, i) { 
									return d.key;
							})
							.on("click", function(d, i) { disp.transition(d, i, true);})
							.append("div")
							.style("color", function(d, i) { return colors(i); });
						row.append("td")
							.attr("class", "table_money")
							.html(function(d) { return format_number(d.income); });
						row.append("td")
							.attr("class", "table_money")
							.html(function(d) { return format_number(d.expense); });
						row.append("td")
							.attr("class", "table_money")
							.html(function(d) { return format_number(d.balance); });
						rows.exit().remove();
						if (node.values.length > display_count) {
							d3.select("#table")
								.append("button")
								.attr("id", "more_button")
								.text("More...")
								.on("click", function() {
									row.style("visibility", "visible")
										.style("display", "table-row");
									d3.select("#more_button").remove();

								});
						}
					}
					return disp;
				}//end display
			});
		</script>
	</body>
</html>
